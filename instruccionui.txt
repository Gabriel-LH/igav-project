Los sistemas grandes NO dependen de matching implÃ­cito al momento del pago.
Lo resuelven antes o fuerzan una acciÃ³n explÃ­cita.

Te explico cÃ³mo lo manejan realmente.

ğŸ”µ 1ï¸âƒ£ CÃ³mo lo hacen los sistemas grandes (retail real)

En retail serio (Zara, H&M, Falabella, etc.) hay tres estrategias comunes:

âœ… Estrategia A â€” BotÃ³n explÃ­cito de bundle (la mÃ¡s usada en POS fÃ­sico)

El vendedor no escanea productos esperando que el sistema â€œadivineâ€.

Hace:

Click en â€œAgregar Pack Ternoâ€

El sistema pide seleccionar:

Saco (escanea)

PantalÃ³n (escanea)

Camisa (escanea)

Se agrupan inmediatamente

Se asigna bundleId

Se bloquea como pack

No hay matching automÃ¡tico ambiguo.

ğŸ‘‰ El POS no â€œdetectaâ€, el operador â€œdeclaraâ€.

Esto elimina el 80% de la complejidad.

âœ… Estrategia B â€” SKU de campaÃ±a (solo en promociones simples)

Ejemplo:

â€œCompra 2 y paga 1â€

AquÃ­ sÃ­ se hace matching automÃ¡tico porque:

Son productos homogÃ©neos

No requieren estructura rÃ­gida

No dependen de combinaciÃ³n especÃ­fica

Pero packs estructurados (terno completo, combo formal, kit de 5 piezas) casi nunca se manejan por detecciÃ³n automÃ¡tica en POS fÃ­sico.

âš ï¸ Estrategia C â€” Matching automÃ¡tico (mÃ¡s comÃºn en e-commerce)

En web sÃ­ se hace matching automÃ¡tico porque:

No hay operador humano

El cliente arma su carrito

El motor promocional analiza combinaciones

Pero incluso en e-commerce grande, el motor:

No corre matching cada vez que pagas

Corre matching incremental cada vez que se modifica el carrito

Marca internamente quÃ© items fueron â€œconsumidosâ€ por un bundle

ğŸ”´ Ahora vamos a tu caso especÃ­fico

â€œEl cliente ya armÃ³ su pack y llega al POS, se escanea todo y reciÃ©n ahÃ­ se hace match.â€

SÃ­, ahÃ­ es donde se vuelve complejo si lo haces automÃ¡tico.

Porque necesitas:

Detectar coincidencias

Calcular cuÃ¡ntos packs completos hay

Separar productos en grupos

Evitar que un mismo producto cuente para dos packs

Recalcular si quitan uno

Eso ya es un pequeÃ±o motor combinatorio.

ğŸ§  CÃ³mo lo resuelven correctamente
ğŸ”· En POS fÃ­sico profesional

NO esperan al momento del pago.

El flujo real es:

Escaneo â†’ motor promocional corre â†’ precio se ajusta en tiempo real.

No se espera al â€œcheckout finalâ€.

Cada vez que entra un producto:

onItemAddedToCart() {
   recalculatePromotions()
}

Nunca se deja para el final.

ğŸ”· CÃ³mo deberÃ­a hacerlo tu sistema

Tienes 2 opciones sÃ³lidas:

ğŸŸ¢ OpciÃ³n Recomendada (POS fÃ­sico)

NO hacer matching automÃ¡tico.

Crear acciÃ³n explÃ­cita:

â€œAplicar Pack Ternoâ€

Flujo:

Vendedor escanea productos normalmente.

Click en â€œAplicar Packâ€.

El sistema valida:

Â¿EstÃ¡n los 4 productos?

Â¿Hay suficientes cantidades?

Si sÃ­:

Se asigna bundleId

Se aplica descuento

Si no:

Mensaje: â€œFaltan productos para completar packâ€

Es simple y controlado.

ğŸŸ¡ OpciÃ³n Avanzada (Matching automÃ¡tico controlado)

Si quieres hacerlo automÃ¡tico:

Debes implementar algoritmo de consumo.

Conceptualmente:

1. Agrupar carrito por productId
2. Calcular nÃºmero mÃ¡ximo de packs posibles
3. Iterar N veces (por cada pack posible):
   - Tomar 1 unidad de cada producto requerido
   - Marcar esas unidades como consumidas
   - Crear bundleId nuevo
4. Lo que sobra queda como venta normal

Clave:
Los items deben tener estado temporal interno tipo:

isConsumedByBundle: boolean

Pero solo en memoria del motor, no en base de datos.

ğŸ”¥ AquÃ­ estÃ¡ el verdadero problema

Si haces matching automÃ¡tico:

Â¿QuÃ© pasa si quitan un producto?

Debes:

Desarmar bundles afectados

Recalcular

Reasignar bundleId

Recalcular descuentos

Eso complica la UX.
ğŸ¯ Por eso en POS fÃ­sicos reales:

La mayorÃ­a usa:

âœ” AcciÃ³n explÃ­cita
âœ” ValidaciÃ³n inmediata
âœ” AgrupaciÃ³n controlada
âœ” Sin heurÃ­sticas mÃ¡gicas

ğŸ“Œ Respuesta directa a tu duda

SÃ­, el sistema debe hacer match solo cuando estÃ©n todos los productos.

Pero en POS fÃ­sico profesional:

No se deja al â€œmomento del pagoâ€

Se resuelve en el momento que se completa la combinaciÃ³n

O se fuerza con botÃ³n explÃ­cito

ğŸ§© Mi recomendaciÃ³n tÃ©cnica para tu arquitectura

Para tu sistema (que ya tiene bundleId y promotionId):

Implementa:

Matching automÃ¡tico solo si quieres UX avanzada.

Pero agrega botÃ³n â€œAplicar Packâ€.

Haz que el botÃ³n sea la forma oficial.

El matching automÃ¡tico solo sugiera:

â€œSe detectÃ³ un pack posible. Â¿Aplicar?â€

Eso combina lo mejor de ambos mundos.